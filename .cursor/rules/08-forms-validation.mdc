---
alwaysApply: true
description: "Padrões para formulários e validação"
---

# Formulários e Validação

## React Hook Form + Zod
```tsx
// ✅ Bom: Formulário completo com validação
"use client"

import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { api } from "@/trpc/react"

const formSchema = z.object({
  email: z.string().email("Email inválido"),
  name: z.string().min(2, "Nome deve ter pelo menos 2 caracteres"),
  role: z.enum(["USER", "ADMIN"]),
  enterprise: z.nativeEnum(Enterprise)
})

type FormData = z.infer<typeof formSchema>

interface UserFormProps {
  user?: User // Para edição
  onSuccess?: () => void
}

export function UserForm({ user, onSuccess }: UserFormProps) {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
    reset
  } = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: user ? {
      email: user.email,
      name: user.name || "",
      role: user.role,
      enterprise: user.enterprise
    } : undefined
  })

  const createUser = api.user.create.useMutation()
  const updateUser = api.user.update.useMutation()

  const onSubmit = async (data: FormData) => {
    try {
      if (user) {
        await updateUser.mutateAsync({ ...data, id: user.id })
      } else {
        await createUser.mutateAsync(data)
      }

      reset()
      onSuccess?.()
    } catch (error) {
      console.error("Erro ao salvar usuário:", error)
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <Label htmlFor="email">Email</Label>
        <Input
          id="email"
          type="email"
          {...register("email")}
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? "email-error" : undefined}
        />
        {errors.email && (
          <p id="email-error" className="text-destructive text-sm">
            {errors.email.message}
        )}
      </div>

      <div>
        <Label htmlFor="name">Nome</Label>
        <Input
          id="name"
          {...register("name")}
          aria-invalid={!!errors.name}
          aria-describedby={errors.name ? "name-error" : undefined}
        />
        {errors.name && (
          <p id="name-error" className="text-destructive text-sm">
            {errors.name.message}
        )}
      </div>

      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Salvando..." : user ? "Atualizar" : "Criar"}
      </Button>
    </form>
  )
}
```

## Campos Customizados
```tsx
// ✅ Bom: Campo de seleção customizado
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"

interface SelectFieldProps {
  label: string
  name: keyof FormData
  register: UseFormRegister<FormData>
  options: { value: string; label: string }[]
  error?: FieldError
}

export function SelectField({ label, name, register, options, error }: SelectFieldProps) {
  return (
    <div>
      <Label htmlFor={name}>{label}</Label>
      <Controller
        name={name}
        control={control}
        render={({ field }) => (
          <Select onValueChange={field.onChange} value={field.value}>
            <SelectTrigger id={name} aria-invalid={!!error}>
              <SelectValue placeholder={`Selecione ${label.toLowerCase()}`} />
            </SelectTrigger>
            <SelectContent>
              {options.map(option => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        )}
      />
      {error && (
        <p className="text-destructive text-sm">
          {error.message}
        </p>
      )}
    </div>
  )
}
```

## Campos de Data
```tsx
// ✅ Bom: Campo de data com validação
import { format } from "date-fns"
import { CalendarIcon } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Calendar } from "@/components/ui/calendar"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"

interface DatePickerProps {
  date?: Date
  onDateChange: (date: Date | undefined) => void
  placeholder?: string
}

export function DatePicker({ date, onDateChange, placeholder = "Selecione uma data" }: DatePickerProps) {
  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          className={`w-full justify-start text-left font-normal ${
            !date && "text-muted-foreground"
          }`}
        >
          <CalendarIcon className="mr-2 h-4 w-4" />
          {date ? format(date, "PPP", { locale: ptBR }) : placeholder}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-auto p-0" align="start">
        <Calendar
          mode="single"
          selected={date}
          onSelect={onDateChange}
          initialFocus
        />
      </PopoverContent>
    </Popover>
  )
}
```

## Upload de Arquivos
```tsx
// ✅ Bom: Upload com preview e validação
import { useState, useRef } from "react"
import { Upload, X } from "lucide-react"
import Image from "next/image"

interface FileUploadProps {
  onFileSelect: (file: File) => void
  accept?: string
  maxSize?: number // em bytes
  preview?: boolean
}

export function FileUpload({
  onFileSelect,
  accept = "image/*",
  maxSize = 5 * 1024 * 1024, // 5MB
  preview = true
}: FileUploadProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null)
  const [previewUrl, setPreviewUrl] = useState<string | null>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file) return

    // Validação de tamanho
    if (file.size > maxSize) {
      alert(`Arquivo muito grande. Máximo: ${maxSize / 1024 / 1024}MB`)
      return
    }

    setSelectedFile(file)
    onFileSelect(file)

    // Preview para imagens
    if (preview && file.type.startsWith('image/')) {
      const url = URL.createObjectURL(file)
      setPreviewUrl(url)
    }
  }

  const removeFile = () => {
    setSelectedFile(null)
    setPreviewUrl(null)
    if (fileInputRef.current) {
      fileInputRef.current.value = ''
    }
  }

  return (
    <div className="space-y-2">
      <input
        ref={fileInputRef}
        type="file"
        accept={accept}
        onChange={handleFileSelect}
        className="hidden"
      />

      {!selectedFile ? (
        <Button
          type="button"
          variant="outline"
          onClick={() => fileInputRef.current?.click()}
          className="w-full h-32 border-dashed"
        >
          <div className="text-center">
            <Upload className="mx-auto h-8 w-8 text-muted-foreground" />
            <p className="mt-2 text-sm text-muted-foreground">
              Clique para selecionar arquivo
            </p>
          </div>
        </Button>
      ) : (
        <div className="relative">
          {preview && previewUrl && (
            <div className="relative h-32 w-full border rounded-lg overflow-hidden">
              <Image
                src={previewUrl}
                alt="Preview"
                fill
                className="object-cover"
              />
            </div>
          )}

          <div className="flex items-center justify-between mt-2 p-2 bg-muted rounded">
            <span className="text-sm truncate">{selectedFile.name}</span>
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={removeFile}
            >
              <X className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}
    </div>
  )
}
```

## Regras para Formulários
- Sempre use React Hook Form para formulários complexos
- Combine com Zod para validação robusta
- Implemente acessibilidade (labels, aria-*)
- Forneça feedback visual claro para erros
- Use loading states durante submissão
- Limpe formulários após sucesso
- Valide tanto no frontend quanto no backend